<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Paper Firehose â€” History Cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #fff;
      --fg: #111;
      --muted: #666;
      --border: #e5e5e5;
      --accent: #0b6cff;
      --card-bg: #fafafa;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      padding: 16px;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 12px; }
    .controls label { font-weight: 600; }
    .controls input[type="text"], .controls select { padding: 6px 8px; font-size: 14px; }
    .controls input[type="file"] { font-size: 14px; }
    button { padding: 6px 10px; font-size: 14px; cursor: pointer; }
    .hint { color: var(--muted); font-size: 12px; }
    .loading { margin-left: 8px; color: var(--muted); }

    /* Layout */
    .wrap { max-width: 1100px; margin: 0 auto; }
    .list { display: grid; grid-template-columns: 1fr; gap: 12px; }

    /* Card */
    .card {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--card-bg);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .title { font-size: 16px; font-weight: 700; line-height: 1.35; }
    .title a { color: var(--fg); text-decoration: none; }
    .title a:hover { color: var(--accent); text-decoration: underline; }
    .meta { display: flex; flex-wrap: wrap; gap: 10px; font-size: 13px; color: var(--muted); }
    .meta .chip { background: #eee; color: #333; border-radius: 999px; padding: 2px 8px; font-weight: 600; }
    .abstract { font-size: 14px; white-space: pre-wrap; }
    .footer { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--muted); margin-top: 2px; }
  </style>
  <!-- MathJax for LaTeX rendering (inline $...$ and $$...$$) -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- sql.js from CDN (WASM SQLite in the browser). Fallbacks included below. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div class="wrap">
    <h1>All matched papers for all topics</h1>
    <div class="controls">
      <label for="dburl">DB URL:</label>
      <input id="dburl" type="text" size="50" placeholder="https://raw.githubusercontent.com/<org>/<repo>/path/.paper_firehose/matched_entries_history.db" />
      <input id="dbfile" type="file" accept=".db" />
      <button id="loadBtn">Load</button>
      <span class="hint">or drop a local matched_entries_history.db file</span>
    </div>
    <div class="controls">
      <label for="topicSel">Topic:</label>
      <select id="topicSel"><option value="__all__">All</option></select>
      <label for="orderSel">Order:</label>
      <select id="orderSel">
        <option value="pub_desc">Published desc</option>
        <option value="pub_asc">Published asc</option>
        <option value="matched_desc">Matched desc</option>
        <option value="matched_asc">Matched asc</option>
        <option value="rank_desc">Rank desc</option>
        <option value="rank_asc">Rank asc</option>
      </select>
      <label for="search">Search:</label>
      <input id="search" type="text" size="24" placeholder="title or authors" />
      <select id="searchIn">
        <option value="all">Title + Authors</option>
        <option value="title">Title only</option>
        <option value="authors">Authors only</option>
      </select>
      <button id="applyBtn">Apply</button>
      <span id="status" class="loading"></span>
    </div>

    <div id="list" class="list" style="display:none"></div>
  </div>

  <script>
    let SQLWasm = null;
    let db = null;
    let allRows = [];

    const DEFAULT_DB_URL_DISPLAY = 'https://raw.githubusercontent.com/zrbyte/paper-firehose/data/.paper_firehose/matched_entries_history.latest.db';
    let SQL_WASM_BASE = 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/';

    function $(id){ return document.getElementById(id); }
    function esc(s){ const d = document.createElement('div'); d.innerText = (s||''); return d.innerHTML; }

    function normalizeGithubRaw(url) {
      try {
        const u = new URL(url);
        if (u.hostname === 'github.com') {
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 5) {
            const owner = parts[0];
            const repo = parts[1];
            const branch = parts[3];
            const path = parts.slice(4).join('/');
            return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
          }
        }
      } catch (_) {}
      return url;
    }

    function parseGithubParts(url) {
      try {
        const u = new URL(url);
        if (u.hostname === 'github.com') {
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 5) {
            const owner = parts[0];
            const repo = parts[1];
            const branch = parts[3];
            const path = parts.slice(4).join('/');
            return { owner, repo, branch, path };
          }
        } else if (u.hostname === 'raw.githubusercontent.com') {
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 4) {
            const owner = parts[0];
            const repo = parts[1];
            const branch = parts[2];
            const path = parts.slice(3).join('/');
            return { owner, repo, branch, path };
          }
        }
      } catch (_) {}
      return null;
    }

    function toJsDelivrURL(parts) {
      const { owner, repo, branch, path } = parts;
      return `https://cdn.jsdelivr.net/gh/${owner}/${repo}@${branch}/${path}`;
    }

    function injectScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(s);
      });
    }

    async function ensureSqlJsLoaded() {
      if (typeof window.initSqlJs === 'function') return;
      try {
        await injectScript('https://unpkg.com/sql.js@1.8.0/dist/sql-wasm.js');
        SQL_WASM_BASE = 'https://unpkg.com/sql.js@1.8.0/dist/';
      } catch (e) {
        await injectScript('https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.js');
        SQL_WASM_BASE = 'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/';
      }
      if (typeof window.initSqlJs !== 'function') {
        throw new Error('sql.js failed to load (initSqlJs is undefined). Check your network or try again.');
      }
    }

    async function initSQL() {
      if (SQLWasm) return SQLWasm;
      await ensureSqlJsLoaded();
      SQLWasm = await initSqlJs({ locateFile: file => `${SQL_WASM_BASE}${file}` });
      return SQLWasm;
    }

    async function loadFromURL(url) {
      const parts = parseGithubParts(url) || parseGithubParts(normalizeGithubRaw(url));
      const candidates = [];
      if (parts) {
        candidates.push(`https://raw.githubusercontent.com/${parts.owner}/${parts.repo}/${parts.branch}/${parts.path}`);
      } else {
        candidates.push(normalizeGithubRaw(url));
      }
      let lastErr = null;
      for (const u of candidates) {
        try {
          const res = await fetch(u);
          if (!res.ok) { lastErr = new Error(`Failed to fetch: ${res.status}`); continue; }
          const buf = await res.arrayBuffer();
          return new Uint8Array(buf);
        } catch (e) { lastErr = e; }
      }
      throw lastErr || new Error('Failed to fetch database');
    }

    function loadFromFile(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(new Uint8Array(r.result));
        r.onerror = reject;
        r.readAsArrayBuffer(file);
      });
    }

    function tableExists(db, name) {
      try {
        const stmt = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?");
        stmt.bind([name]);
        const exists = stmt.step();
        stmt.free();
        return !!exists;
      } catch (_) { return false; }
    }

    function getTableColumns(db, name) {
      try {
        const stmt = db.prepare(`PRAGMA table_info(${name})`);
        const cols = [];
        while (stmt.step()) cols.push(stmt.getAsObject().name);
        stmt.free();
        return cols;
      } catch (_) { return []; }
    }

    function parseRows(db) {
      if (!tableExists(db, 'matched_entries')) {
        throw new Error("Table 'matched_entries' not found in database");
      }
      const cols = new Set(getTableColumns(db, 'matched_entries'));
      const stmt = db.prepare(`SELECT * FROM matched_entries`);
      const rows = [];
      while (stmt.step()) {
        const v = stmt.getAsObject();
        v.feed_name = v.feed_name || '';
        v.title = v.title || '';
        v.link = v.link || '';
        v.authors = v.authors || v.author || '';
        v.abstract = v.abstract || v.summary || '';
        v.published_date = v.published_date || v.published || '';
        v.matched_date = v.matched_date || '';
        v.topics = v.topics || v.topic || '';
        rows.push(v);
      }
      stmt.free();
      if (!cols.has('topics') && !cols.has('topic')) {
        console.warn("Viewer: no 'topics' column found; topic filter will show empty values.");
      }
      return rows;
    }

    function renderTopics(rows) {
      const set = new Set();
      rows.forEach(r => {
        (r.topics || '').split(',').map(x => x.trim()).filter(Boolean).forEach(t => set.add(t));
      });
      const sel = $('topicSel');
      sel.innerHTML = '<option value="__all__">All</option>' + Array.from(set).sort().map(t => `<option>${esc(t)}</option>`).join('');
    }

    function sortRows(rows, order) {
      let field = 'published_date';
      let dir = 'desc';
      let byRank = false;
      if (typeof order === 'string') {
        if (order.startsWith('pub')) field = 'published_date';
        if (order.startsWith('matched')) field = 'matched_date';
        if (order.startsWith('rank')) byRank = true;
        if (order.endsWith('_asc')) dir = 'asc';
        if (order.endsWith('_desc')) dir = 'desc';
      }
      const copy = rows.slice();
      if (byRank) {
        return copy.sort((a,b) => {
          const av = parseFloat(a.rank_score || a.rank || '0') || 0;
          const bv = parseFloat(b.rank_score || b.rank || '0') || 0;
          const cmp = av < bv ? -1 : (av > bv ? 1 : 0);
          return dir === 'asc' ? cmp : -cmp;
        });
      }
      return copy.sort((a,b) => {
        const av = (a[field]||'').trim();
        const bv = (b[field]||'').trim();
        if (!av && !bv) return 0;
        if (!av) return 1;
        if (!bv) return -1;
        const cmp = av < bv ? -1 : (av > bv ? 1 : 0);
        return dir === 'asc' ? cmp : -cmp;
      });
    }

    function applyFilterAndRender() {
      const topic = $('topicSel').value;
      const order = $('orderSel').value;
      const q = $('search').value.trim().toLowerCase();
      const searchIn = $('searchIn').value;
      let rows = allRows;
      if (topic && topic !== '__all__') {
        rows = rows.filter(r => (r.topics||'').split(',').map(x=>x.trim()).includes(topic));
      }
      if (q) {
        rows = rows.filter(r => {
          const t = (r.title||'').toLowerCase();
          const a = (r.authors||'').toLowerCase();
          if (searchIn === 'title') return t.includes(q);
          if (searchIn === 'authors') return a.includes(q);
          return t.includes(q) || a.includes(q);
        });
      }
      rows = sortRows(rows, order);

      const list = $('list');
      list.innerHTML = '';
      rows.forEach(r => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="title"><a href="${esc(r.link||'#')}" target="_blank" rel="noopener">${esc(r.title||'Untitled')}</a></div>
          <div class="meta">
            <span class="chip">${esc(r.feed_name||'')}</span>
            <span>${esc(r.authors||'')}</span>
          </div>
          <div class="abstract"></div>
          <div class="footer"><span>Published: ${esc(r.published_date||'')} &bull; Matched: ${esc(r.matched_date||'')}</span></div>
        `;
        // Insert abstract as HTML (to support MathJax + MathML from sources),
        // with minimal sanitization to strip scripts/styles and event handlers.
        const abs = (r.abstract || '').toString();
        const sanitized = abs
          .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
          .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
          .replace(/<iframe[^>]*>[\s\S]*?<\/iframe>/gi, '')
          .replace(/<object[^>]*>[\s\S]*?<\/object>/gi, '')
          .replace(/<embed[^>]*>[\s\S]*?<\/embed>/gi, '')
          .replace(/ on[a-z]+\s*=\s*("[^"]*"|'[^']*'|[^\s>]+)/gi, '');
        card.querySelector('.abstract').innerHTML = sanitized;
        list.appendChild(card);
      });
      $('list').style.display = '';
      $('status').textContent = `${rows.length} entries`;
      // Trigger MathJax typesetting for newly injected content
      if (window.MathJax && MathJax.typesetPromise) {
        try { MathJax.typesetPromise([list]); } catch (_) {}
      }
    }

    async function loadDB(bytes) {
      const SQL = await initSQL();
      if (db) { db.close(); db = null; }
      db = new SQL.Database(bytes);
      allRows = parseRows(db);
      renderTopics(allRows);
      applyFilterAndRender();
    }

    async function handleLoadClick() {
      $('status').textContent = 'Loading...';
      try {
        const file = $('dbfile').files[0];
        const url = $('dburl').value.trim();
        if (file) {
          const bytes = await loadFromFile(file);
          await loadDB(bytes);
        } else if (url) {
          const bytes = await loadFromURL(url);
          await loadDB(bytes);
        } else {
          $('status').textContent = 'Please choose a file or enter a URL';
          return;
        }
        $('status').textContent = 'Loaded';
      } catch (e) {
        console.error(e);
        $('status').textContent = 'Error: ' + (e.message || e);
      }
    }

    function tryAutoLoadFromQuery() {
      const params = new URLSearchParams(location.search);
      const dbParam = params.get('db');
      const topic = params.get('topic');
      const order = params.get('order');
      if (dbParam) {
        $('dburl').value = dbParam;
        handleLoadClick();
      }
      if (topic) {
        const updateTopic = () => { const sel = $('topicSel'); if (sel.options.length>0) sel.value = topic; };
        setTimeout(updateTopic, 1500);
      }
      if (order) {
        let normalized = order;
        if (order === 'asc' || order === 'desc') normalized = `pub_${order}`;
        if (order.startsWith('published_')) normalized = order.replace('published_', 'pub_');
        const allowed = new Set(['pub_asc','pub_desc','matched_asc','matched_desc','rank_asc','rank_desc']);
        if (allowed.has(normalized)) $('orderSel').value = normalized;
      }
    }

    // Init
    (function initUI() {
      $('dburl').value = DEFAULT_DB_URL_DISPLAY;
    })();
    $('loadBtn').addEventListener('click', handleLoadClick);
    $('applyBtn').addEventListener('click', applyFilterAndRender);
    $('search').addEventListener('keydown', e => { if (e.key === 'Enter') applyFilterAndRender(); });
    window.addEventListener('dragover', e => { e.preventDefault(); });
    window.addEventListener('drop', async e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        $('dbfile').files = e.dataTransfer.files;
        await handleLoadClick();
      }
    });
    tryAutoLoadFromQuery();
    if (!(new URLSearchParams(location.search)).get('db')) {
      setTimeout(() => { if ($('dburl').value) handleLoadClick(); }, 50);
    }
  </script>
</body>
</html>

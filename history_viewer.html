<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Paper Firehose â€” History Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 12px; }
    .controls label { font-weight: 600; }
    .controls input[type="text"], .controls select { padding: 6px 8px; font-size: 14px; }
    button { padding: 6px 10px; font-size: 14px; cursor: pointer; }
    .hint { color: #666; font-size: 12px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #e5e5e5; padding: 8px; vertical-align: top; }
    th { background: #f8f8f8; text-align: left; }
    tr:nth-child(even) { background: #fcfcfc; }
    .muted { color: #777; }
    .nowrap { white-space: nowrap; }
    .loading { margin-top: 8px; }
  </style>
  <!-- sql.js from CDN (WASM SQLite in the browser). We'll also add a runtime fallback if this fails. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <h1>History Viewer</h1>
  <div class="controls">
    <label for="dburl">DB URL:</label>
    <input id="dburl" type="text" size="50" placeholder="https://raw.githubusercontent.com/<org>/<repo>/data/matched_entries_history.db" />
    <input id="dbfile" type="file" accept=".db" />
    <button id="loadBtn">Load</button>
    <span class="hint">or drop a local matched_entries_history.db file</span>
  </div>
  <div class="controls">
    <label for="topicSel">Topic:</label>
    <select id="topicSel"><option value="__all__">All</option></select>
    <label for="orderSel">Order:</label>
    <select id="orderSel">
      <option value="desc">Published desc</option>
      <option value="asc">Published asc</option>
    </select>
    <label for="search">Search:</label>
    <input id="search" type="text" size="24" placeholder="title or authors" />
    <select id="searchIn">
      <option value="all">Title + Authors</option>
      <option value="title">Title only</option>
      <option value="authors">Authors only</option>
    </select>
    <button id="applyBtn">Apply</button>
    <span id="status" class="loading"></span>
  </div>

  <table id="table" style="display:none">
    <thead>
      <tr>
        <th>Feed</th>
        <th>Title</th>
        <th>Authors</th>
        <th>Published</th>
        <th>Topics</th>
        <th>DOI</th>
        <th>Abstract</th>
        <th>LLM Summary</th>
        <th>PaperQA Summary</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let SQLWasm = null;
    let db = null;
    let allRows = [];

    // Default remote DB (shown in the input). We normalize to raw when fetching.
    const DEFAULT_DB_URL_DISPLAY = 'https://github.com/zrbyte/paper-firehose/tree/data/assets/matched_entries_history.latest.db';
    // Preferred base to load the wasm from; we will switch if we use a fallback loader.
    let SQL_WASM_BASE = 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/';

    function $(id){ return document.getElementById(id); }
    function esc(s){ const d = document.createElement('div'); d.innerText = (s||''); return d.innerHTML; }

    function normalizeGithubRaw(url) {
      try {
        const u = new URL(url);
        if (u.hostname === 'github.com') {
          // Turn https://github.com/{owner}/{repo}/(blob|tree)/{branch}/{path...}
          // into https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path...}
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 5) {
            const owner = parts[0];
            const repo = parts[1];
            // parts[2] is 'blob' or 'tree'
            const branch = parts[3];
            const path = parts.slice(4).join('/');
            return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
          }
        }
      } catch (_) {}
      return url;
    }

    function parseGithubParts(url) {
      try {
        const u = new URL(url);
        if (u.hostname === 'github.com') {
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 5) {
            const owner = parts[0];
            const repo = parts[1];
            const branch = parts[3];
            const path = parts.slice(4).join('/');
            return { owner, repo, branch, path };
          }
        } else if (u.hostname === 'raw.githubusercontent.com') {
          const parts = u.pathname.split('/').filter(Boolean);
          if (parts.length >= 4) {
            const owner = parts[0];
            const repo = parts[1];
            const branch = parts[2];
            const path = parts.slice(3).join('/');
            return { owner, repo, branch, path };
          }
        }
      } catch (_) {}
      return null;
    }

    function toJsDelivrURL(parts) {
      const { owner, repo, branch, path } = parts;
      return `https://cdn.jsdelivr.net/gh/${owner}/${repo}@${branch}/${path}`;
    }

    function injectScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(s);
      });
    }

    async function ensureSqlJsLoaded() {
      if (typeof window.initSqlJs === 'function') return;
      // Try a fallback CDN if the primary failed to load
      try {
        await injectScript('https://unpkg.com/sql.js@1.8.0/dist/sql-wasm.js');
        SQL_WASM_BASE = 'https://unpkg.com/sql.js@1.8.0/dist/';
      } catch (e) {
        // As a final attempt, try jsDelivr
        await injectScript('https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.js');
        SQL_WASM_BASE = 'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/';
      }
      if (typeof window.initSqlJs !== 'function') {
        throw new Error('sql.js failed to load (initSqlJs is undefined). Check your network or try again.');
      }
    }

    async function initSQL() {
      if (SQLWasm) return SQLWasm;
      await ensureSqlJsLoaded();
      SQLWasm = await initSqlJs({ locateFile: file => `${SQL_WASM_BASE}${file}` });
      return SQLWasm;
    }

    async function loadFromURL(url) {
      const parts = parseGithubParts(url) || parseGithubParts(normalizeGithubRaw(url));
      const candidates = [];
      if (parts) {
        // Prefer jsDelivr for better CORS from file:// origins; fall back to raw.
        candidates.push(toJsDelivrURL(parts));
        candidates.push(`https://raw.githubusercontent.com/${parts.owner}/${parts.repo}/${parts.branch}/${parts.path}`);
      } else {
        candidates.push(normalizeGithubRaw(url));
      }

      let lastErr = null;
      for (const u of candidates) {
        try {
          const res = await fetch(u);
          if (!res.ok) { lastErr = new Error(`Failed to fetch: ${res.status}`); continue; }
          const buf = await res.arrayBuffer();
          return new Uint8Array(buf);
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('Failed to fetch database');
    }

    function loadFromFile(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(new Uint8Array(r.result));
        r.onerror = reject;
        r.readAsArrayBuffer(file);
      });
    }

    function tableExists(db, name) {
      try {
        const stmt = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?");
        stmt.bind([name]);
        const exists = stmt.step();
        stmt.free();
        return !!exists;
      } catch (_) { return false; }
    }

    function getTableColumns(db, name) {
      try {
        const stmt = db.prepare(`PRAGMA table_info(${name})`);
        const cols = [];
        while (stmt.step()) {
          const row = stmt.getAsObject();
          cols.push(row.name);
        }
        stmt.free();
        return cols;
      } catch (_) { return []; }
    }

    function parseRows(db) {
      if (!tableExists(db, 'matched_entries')) {
        throw new Error("Table 'matched_entries' not found in database");
      }
      const cols = new Set(getTableColumns(db, 'matched_entries'));
      const stmt = db.prepare(`SELECT * FROM matched_entries`);
      const rows = [];
      while (stmt.step()) {
        const v = stmt.getAsObject();
        // Normalize fields for rendering
        v.feed_name = v.feed_name || '';
        v.title = v.title || '';
        v.link = v.link || '';
        v.summary = v.summary || '';
        v.authors = v.authors || v.author || '';
        v.abstract = v.abstract || '';
        v.llm_summary = v.llm_summary || '';
        v.paper_qa_summary = v.paper_qa_summary || '';
        v.doi = v.doi || '';
        v.published_date = v.published_date || v.published || '';
        v.matched_date = v.matched_date || '';
        v.topics = v.topics || v.topic || '';
        rows.push(v);
      }
      stmt.free();
      // Quick warning if topics column truly absent
      if (!cols.has('topics') && !cols.has('topic')) {
        console.warn("Viewer: no 'topics' column found; topic filter will show empty values.");
      }
      return rows;
    }

    function renderTopics(rows) {
      const set = new Set();
      rows.forEach(r => {
        (r.topics || '').split(',').map(x => x.trim()).filter(Boolean).forEach(t => set.add(t));
      });
      const sel = $('topicSel');
      sel.innerHTML = '<option value="__all__">All</option>' + Array.from(set).sort().map(t => `<option>${esc(t)}</option>`).join('');
    }

    function sortRows(rows, order) {
      return rows.slice().sort((a,b) => {
        const ap = (a.published_date||'').trim();
        const bp = (b.published_date||'').trim();
        if (!ap && !bp) return 0;
        if (!ap) return 1; // empty last
        if (!bp) return -1;
        return (ap < bp ? -1 : (ap > bp ? 1 : 0)) * (order === 'asc' ? 1 : -1);
      });
    }

    function applyFilterAndRender() {
      const topic = $('topicSel').value;
      const order = $('orderSel').value;
      const q = $('search').value.trim().toLowerCase();
      const searchIn = $('searchIn').value;
      let rows = allRows;
      if (topic && topic !== '__all__') {
        rows = rows.filter(r => (r.topics||'').split(',').map(x=>x.trim()).includes(topic));
      }
      if (q) {
        rows = rows.filter(r => {
          const t = (r.title||'').toLowerCase();
          const a = (r.authors||'').toLowerCase();
          if (searchIn === 'title') return t.includes(q);
          if (searchIn === 'authors') return a.includes(q);
          return t.includes(q) || a.includes(q);
        });
      }
      rows = sortRows(rows, order);

      const tbody = $('table').querySelector('tbody');
      tbody.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        const doi = (r.doi||'').trim();
        const doiHTML = doi ? `<a href="https://doi.org/${esc(doi)}" target="_blank" rel="noopener">${esc(doi)}</a>` : '';
        tr.innerHTML = `
          <td>${esc(r.feed_name||'')}</td>
          <td><a href="${esc(r.link||'#')}" target="_blank" rel="noopener">${esc(r.title||'')}</a></td>
          <td>${esc(r.authors||'')}</td>
          <td class="nowrap"><span class="muted">${esc(r.published_date||'')}</span></td>
          <td>${esc(r.topics||'')}</td>
          <td>${doiHTML}</td>
          <td>${esc(r.abstract||'')}</td>
          <td>${esc(r.llm_summary||'')}</td>
          <td>${esc(r.paper_qa_summary||'')}</td>
        `;
        tbody.appendChild(tr);
      });
      $('table').style.display = '';
      $('status').textContent = `${rows.length} rows`;
    }

    async function loadDB(bytes) {
      const SQL = await initSQL();
      if (db) { db.close(); db = null; }
      db = new SQL.Database(bytes);
      allRows = parseRows(db);
      renderTopics(allRows);
      applyFilterAndRender();
    }

    async function handleLoadClick() {
      $('status').textContent = 'Loading...';
      try {
        const file = $('dbfile').files[0];
        const url = $('dburl').value.trim();
        if (file) {
          const bytes = await loadFromFile(file);
          await loadDB(bytes);
        } else if (url) {
          const bytes = await loadFromURL(url);
          await loadDB(bytes);
        } else {
          $('status').textContent = 'Please choose a file or enter a URL';
          return;
        }
        $('status').textContent = 'Loaded';
      } catch (e) {
        console.error(e);
        $('status').textContent = 'Error: ' + (e.message || e);
      }
    }

    function tryAutoLoadFromQuery() {
      const params = new URLSearchParams(location.search);
      const dbParam = params.get('db');
      const topic = params.get('topic');
      const order = params.get('order');
      if (dbParam) {
        $('dburl').value = dbParam;
        handleLoadClick();
      }
      if (topic) {
        const updateTopic = () => { const sel = $('topicSel'); if (sel.options.length>0) sel.value = topic; };
        // Try later as well when topics populate
        setTimeout(updateTopic, 1500);
      }
      if (order && (order === 'asc' || order === 'desc')) {
        $('orderSel').value = order;
      }
    }

    // Initialize controls and attempt default load when no query is provided
    (function initUI() {
      $('dburl').value = DEFAULT_DB_URL_DISPLAY;
    })();

    $('loadBtn').addEventListener('click', handleLoadClick);
    $('applyBtn').addEventListener('click', applyFilterAndRender);
    $('search').addEventListener('keydown', e => { if (e.key === 'Enter') applyFilterAndRender(); });
    window.addEventListener('dragover', e => { e.preventDefault(); });
    window.addEventListener('drop', async e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        $('dbfile').files = e.dataTransfer.files;
        await handleLoadClick();
      }
    });
    tryAutoLoadFromQuery();
    // If no explicit ?db= query, attempt loading the default URL automatically
    if (!(new URLSearchParams(location.search)).get('db')) {
      // Defer a tick to allow the page to paint
      setTimeout(() => {
        if ($('dburl').value) {
          handleLoadClick();
        }
      }, 50);
    }
  </script>
</body>
</html>
